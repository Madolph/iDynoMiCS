/**
 * Project iDynoMiCS (copyright -> see Idynomics.java)
 *  
 *_____________________________________________________
 * Implements static utility functions for used in multigrid method.
 * 
 */
 
/**
 * @since August 2011
 * @version 1.0
 * @author Katrin Bohl, FSU Jena
 * @author Max Adolph, TU Dresden
 */


package simulator.diffusionSolver.multigrid;

import simulator.geometry.Domain;
import simulator.geometry.boundaryConditions.AllBC;
import simulator.Simulator;
import simulator.SoluteGrid;
import utils.LogFile;
import utils.MatrixOperations;

public class MultigridSoluteTimeDependent 
{
	/**
	 * TODO Is this actually used?
	 */
	public int						Agarlayerheight = 0;
	
	public String                   soluteName;
	
	/**
	 * realGrid stores the actual, fine concentration-grid, while _conc is used
	 * for inner computations (and some things, that are actually a bit of a stretch...)
	 */
	public SoluteGrid               realGrid;
	
	/**
	 * The stable time-step according to the diffusivity of this solute.
	 */
	public Double 					simTimeStep;					
	
	/**
	 * Length or height of represented domain.
	 */
	public Double					_referenceSystemSide;
	
	protected Domain				_domain;
	
	/**
	 * The Bulk-concentration of this Solute
	 */
	protected Double				sBulk;

	
	/**
	 * our computational grid. Is treated as the main grid during the diffusion-calculation
	 * and also used for stuff like boundary-Layer-values and biomass-concentrations
	 */
	public SoluteGrid				_conc; 
	
	/**
	 * stores the reaction rate inside the corresponding voxel
	 */
	public SoluteGrid				_reac; 
	
	/**
	 * not directly used, but since we use the same "updateReac", we need it
	 * (shallow copies the steady-State anyway, so it should not take up more memory)
	 */
	public SoluteGrid				_diffReac; 

	/**
	 * Concentration-Grid used for Computation
	 */
	private static int				_i, _j, _k;
	
	/**
	 * Constant value to determine if a voxel has to be considered for
	 * calculation.
	 */
	public static final Double		BLTHRESH = 0.1;
	
	private static int				_nI, _nJ, _nK;

	Simulator						mySim;
	
	
	public MultigridSoluteTimeDependent(SoluteGrid aSolute, MultigridSoluteTimeDependent relDiff, 
			              MultigridSoluteTimeDependent bLayer, Simulator aSim, double sBulk, int nReac) 
	{
		mySim=aSim;
		
		realGrid = aSolute;
		soluteName = realGrid.gridName;
		_i = realGrid.getGridSizeI();
		_j = realGrid.getGridSizeJ();
		_k = realGrid.getGridSizeK();
		_domain = realGrid.getDomain();
		
		for ( AllBC e : _domain.getAllBoundaries() )
			if ( e.getAgarlayerHeightD() > 0 )
				this.Agarlayerheight = e.getAgarlayerHeightD();
		
		setReferenceSide();
		this.sBulk = sBulk;
			
		Double r = _referenceSystemSide/referenceIndex(_i,_j,_k);

		// Padding is automatically generated by the constructor
		_conc = new SoluteGrid(_i, _j, _k, r, aSolute);
		_reac = new SoluteGrid(_i, _j, _k, r, aSolute);
		_diffReac = new SoluteGrid(_i, _j, _k, r, aSolute);
	}
	
	/**
	 * \brief Constructor used for biomass, bLayer and relative diffusivity grids
	 * 
	 * Constructor used for biomass, bLayer and relative diffusivity grids
	 * 
	 * @param aSolute	SoluteGrid to be used by the Multigrid
	 * @param gridName	Name of the solute grid
	 */
	public MultigridSoluteTimeDependent(SoluteGrid aSolute, String gridName) 
	{
		soluteName = gridName;
		_domain = aSolute.getDomain();
		realGrid = aSolute;

		_nI = aSolute.getGridSizeI();
		_nJ = aSolute.getGridSizeJ();
		_nK = aSolute.getGridSizeK();
		
		//sonia:chemostat
		if(Simulator.isChemostat)
			_conc= new SoluteGrid(_nI, _nJ, _nK, _domain._resolution, aSolute);
		else
		{
			setReferenceSide();
				
			double r = _referenceSystemSide/referenceIndex(_nI,_nJ,_nK);

			// with padding for boundary conditions
			_conc = new SoluteGrid(_nI, _nJ, _nK, r, aSolute);
		}
	}
	
	/**
	 * Update bulk concentration.
	 */
	public void readBulk() 
	{
		for (AllBC aBC : _domain.getAllBoundaries()) 
			if (aBC.hasBulk())
				sBulk = aBC.getBulk().getValue(realGrid.soluteIndex);
		
	}
	
	/**
	 * Transforms a Matrix A (A*t=d) into an identity matrix. This gives a pattern for the
	 * righthand-side, that we can solve to acquire a solution.
	 * 
	 * @param A the Matrix
	 * @param d the righthand-side
	 * @param t the vector to be solved
	 * @author Max Adolph, TU Dresden
	 */
	public void pivotSolver(double[][] A, double[] d, double[] t) 
	{	
		/*
		 * This part is basically doing the same as the Thomas algorithm for
		 * tridiagonal matrices, but we don't want to solve the system right
		 * away. Instead, we take the transformed matrix and do a second step,
		 * that is explained below.
		 */
		double[] u = new double[A.length-1];
		double[] b = new double[A.length];
		double[] k = new double[d.length];
		double c;
		for (int i=0;i<A.length;i++)
		{
			if (i==0)
				b[i]=A[i][i];
			else
				b[i]=A[i][i]-(A[i][i-1]*A[i-1][i]/b[i-1]);
		}
		
		for (int i=0;i<u.length;i++)
		{
			u[i]=A[i+1][i]/b[i];
		}
		
		for (int i=0;i<d.length;i++)
		{
			if (i==0)
				k[i]=d[i]/b[i];
			else
				k[i]=(d[i]-(k[i-1]*A[i-1][i]))/b[i];
		}
		
		/* if we assume that the Matrix was 
		 * 1  u1 0  | k1
		 * 0  1  u2 | k2
		 * 0  0  1  | k3
		 * before this Algorithm, transforming the lefthand-side 
		 * to the identity matrix leaves the righthand-side in a specific pattern.
		 * 
		 * for 3x3, thats
		 * 1 0 0 | k1 - k2*u1 + k3*u1*u2
		 * 0 1 0 | k2 - k3*u2
		 * 0 0 1 | k3
		 * 
		 * For bigger systems, it follows the same pattern... but you
		 * might just want to trust me on this
		 * (unless you have time to check it yourself, in which case: "knock yourself out")
		 */
		
		// i runs through all elements of the result-vector
		for (int i=t.length-1;i>=0;i--)
		{
			t[i]=k[i];
			// h runs through the elements that have to be added or subtracted (the k's)
			for (int h=t.length-1-i;h>0;h--)
			{
				c=1.0;
				// p runs through the coefficients for the specific elements (the u's) and sums them up in c
				for (int p=0;p<h;p++)
				{
					c=c*u[p+i];			
				}
				// decide, whether the element gets subtracted or added (depends on the "distance" of the elements)
				if (h%2!=0)
					t[i]=t[i]-k[i+h]*c;
				else
					t[i]=t[i]+k[i+h]*c;
			}
		}
	}
	
	/**
	 * set of methods to simplify the implicit Crank-Nicolson-Method
	 * 
	 * @param rd relative Diffusivity grid
	 * @param he current height (x)
	 * @param wi current width (y)
	 * @param de current depth (z)
	 * @return the actual Diffusivity between two elements
	 */
	public double calcLocalDiffZ(double[][][] rd, int he, int wi, int de)
	{
		double relDiff = 0;
			relDiff = realGrid.diffusivity*(rd[he][wi][de]+rd[he][wi][de+1])/2;
		
		return relDiff;
	}
	
	/**
	 * set of methods to simplify the implicit Crank-Nicolson-Method
	 * 
	 * @param rd relative Diffusivity grid
	 * @param he current height (x)
	 * @param wi current width (y)
	 * @param de current depth (z)
	 * @return the actual Diffusivity between two elements
	 */
	public double calcLocalDiffY(double[][][] rd, int he, int wi, int de)
	{
		double relDiff = 0;
			relDiff = realGrid.diffusivity*(rd[he][wi][de]+rd[he][wi+1][de])/2;
		
		return relDiff;
	}
	
	/**
	 * set of methods to simplify the implicit Crank-Nicolson-Method
	 * 
	 * @param rd relative Diffusivity grid
	 * @param he current height (x)
	 * @param wi current width (y)
	 * @param de current depth (z)
	 * @return the actual Diffusivity between two elements
	 */
	public double calcLocalDiffX(double[][][] rd, int he, int wi, int de)
	{
		double relDiff = 0;
			relDiff = realGrid.diffusivity*(rd[he][wi][de]+rd[he+1][wi][de])/2;
		
		return relDiff;
	}
	
	/**
	 * \brief Solves the Diffusion according to the implicit Crank-Nicolson 
	 * Method.
	 * 
	 * The spatial Dimensions are independent and therefore solved separately,
	 * breaking the domain down in 1D-parts. 2D Matrices are made up for
	 * computation. These are tridiagonal Matrices that represent a set of linear equations
	 * along with their corresponding vectors. The unknown vector represents
	 * our future concentration and can be computed, because the rest of the system is known.
	 * 
	 * @param dt		the timestep
	 * @param step		the value-receiving grid
	 * @param _bLayer 	the Boundary-Layer/Biomass-grid
	 * @param rd    	the relative diffusivity-grid
	 * @param refresh 	should the domain outside the bLayer be set to bulk constantly?
	 */
	public void implCrankNic(SoluteGrid conc, double dt, 
			MultigridSoluteTimeDependent _bLayer, double[][][] rd, boolean refresh) 
	{
		/* 
		 * gets the lengths of the grids without padding
		 */
		int nI = conc.grid.length - 2;
		int nJ = conc.grid[1].length - 2;
		int nK = conc.grid[1][1].length - 2;
		
		//refesh our padding properly
		conc.refreshBoundary("conc");
		
		LogFile.writeLogAlways("nI: "+nI+" / nJ: "+nJ+" / nK: "+nK);
		
		// size of our finite elemets
		double h = _referenceSystemSide/referenceIndex(nI,nJ,nK);
		
		// The constant term of our matrices
		double diag = 2*h*h/dt;
		
		LogFile.writeLogAlways("h: "+h+" / dt: "+dt+" / const: "+diag);
			
		// Create the flux grids.
		double[][][] XYZ = new double [nI+2][nJ+2][nK+2];
		double[][][] X = new double[nI+2][nJ+2][nK+2];
		double[][][] Y = new double[nI+2][nJ+2][nK+2];
		double[][][] Z = new double[nI+2][nJ+2][nK+2];
		
		/*
		 * The steps for the domains all have the same behaviour, all that changes are the 
		 * spatial counters.
		 */
		//solve in Z
		for ( int x = 0; x < nI+2; x++ )
			for (int y = 0; y < nJ+2; y++ )
			{
				int nKi;
				if ( x == 0 || x == nI+1 || y == 0 || y == nJ+1 )
					nKi=nK;
				else
					nKi=nK+2;
				
				// our Matrix for t+1
				double[][] A = new double[nKi][nKi];
				// our Matrix for the current time
				double[][] B = new double[nKi][nKi];
				// B times the vector of concentrations
				double[] d = new double[nKi];
				// the vector of concentrations after the time-step
				double[] t = new double[nKi];
				
				if ( nKi == 1 )
					Z[x][y][0] = 0.0;
				else
				{
					//set A (Matrix of t+)
					for ( int z = 0; z < nKi; z++ )
					{
						/*
						 * These Block-messages are found throughout the whole method. They can be largely
						 * ignored, since their only purpose is to rearrange counters if we are at the edge
						 * of our domain. This is necessary, because our domain misses edges and corners
						 */
						
						/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
						//this is necessary to get around the corners of the padding 
						if ( x == 0 || x == nI+1 || y == 0 || y == nJ+1 ) /*corrects z in edge-case*/ 
							de = z+1;
						else /*normal case*/ 
							de = z;	
						he=x; wi=y;	/*and the other coordinates (for consistency)*/
						
						// the upper corner
						if ( z == 0 )
							// represents [2h²/dt] as diag and [D] as calcLocalDiff
							A[z][z]= diag+(calcLocalDiffZ(rd, he, wi, de));
						// the lower corner
						if ( z == nKi-1 )
							A[z][z]= diag+(calcLocalDiffZ(rd, he, wi, de-1));
						// the main diagonal
						if ( z != 0 && z != nKi-1 )
							A[z][z]= diag+(calcLocalDiffZ(rd, he, wi, de)+calcLocalDiffZ(rd, he, wi, de-1));
						
						//set values left and right of the diagonal
						if ( z > 0 ) // does not exist in upper corner
							A[z-1][z] = -calcLocalDiffZ(rd, he, wi, de-1);
						
						if ( z < nKi-1 ) // does not exist in lower corner
							A[z+1][z] = -calcLocalDiffZ(rd, he, wi, de);
					}
		
					//set B (Matrix of t0)
					for (int z=0;z<nKi;z++)
					{
						/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
						//this is necessary to get around the corners of the padding 
						if (x==0 || x==nI+1 || y==0 || y==nJ+1) /*corrects z in edge-case*/ 
							de=z+1;
						else /*normal case*/ 
							de=z;
						he=x; wi=y; /*and the other coordinates (for consistency)*/
							
						if (z==0)
							B[z][z]= diag-calcLocalDiffZ(rd, he, wi, de);
						if (z==nKi-1)
							B[z][z]= diag-calcLocalDiffZ(rd, he, wi, de-1);
						if (z!=0 && z!=nKi-1)
							B[z][z]= diag-calcLocalDiffZ(rd, he, wi, de)-calcLocalDiffZ(rd, he, wi, de-1);
							
						if (z>0)
							B[z-1][z]= calcLocalDiffZ(rd, he, wi, de-1);
						if (z<nKi-1)
							B[z+1][z]= calcLocalDiffZ(rd, he, wi, de);
					}
		
					//set d (Flux-Matrix B * concentration-vector d)
					for ( int z = 0; z < nKi; z++ )
					{
						/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
						//this is necessary to get around the corners of the padding 
						if (x==0 || x==nI+1 || y==0 || y==nJ+1) /*corrects z in edge-case*/ 
							de=z+1;
						else /*normal case*/
							de=z;
						he=x; wi=y; /*and the other coordinates (for consistency)*/ 
						
						Double sum = B[z][z]*conc.grid[he][wi][de];
						// every points except lower corner
						if ( z < nKi-1 )
							sum += B[z+1][z]*conc.grid[he][wi][de+1];
						// every point except upper corner
						if ( z > 0 )
							sum += B[z-1][z]*conc.grid[he][wi][de-1];
						d[z] = sum;
					}
						
					// Solves the tridiagonal Matrix (computes the concentration-vector t, that corresponds to A)
					pivotSolver(A, d, t);
						
					//assign Flux
					for (int z=0;z<nKi;z++)
					{
						/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
						//this is necessary to get around the corners of the padding 
						if (x==0 || x==nI+1 || y==0 || y==nJ+1) /*corrects z in edge-case*/ 
							de=z+1;
						else /*normal case*/ 
							de=z; 
						he=x; wi=y; /*and the other coordinates (for consistency)*/
						
						Z[x][y][z]=t[z]-conc.grid[he][wi][de];
					}
				}
			}
		
		//solve in Y
		for (int x=0;x<nI+2;x++)
			for (int z=0;z<nK+2;z++)
			{
				int nJi;
				if (x==0 || x==nI+1 || z==0 || z==nK+1)
					nJi=nJ;
				else
					nJi=nJ+2;
				
				double[][] A = new double[nJi][nJi];
				double[][] B = new double[nJi][nJi];
				double[] d = new double[nJi];
				double[] t = new double[nJi];
				
				if (nJi==1)
					Y[x][0][z] = 0;
				else
				{
					//set A
					for (int y = 0; y < nJi; y++ )
					{
						/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
						//this is necessary to get around the corners of the padding 
						if ( x == 0 || x == nI+1 || z == 0 || z == nK+1 ) /*corrects y in edge-case*/ 
							wi = y+1;
						else /*normal case*/ 
							wi = y;	 
						he=x; de=z; /*and the other coordinates (for consistency)*/
							
						if (y==0)
							A[y][y]=diag+calcLocalDiffY(rd, he, wi, de);
						if (y==nJi-1)
							A[y][y]=diag+calcLocalDiffY(rd, he, wi-1, de);
						if (y!=0 && y!=nJi-1)
							A[y][y]=diag+calcLocalDiffY(rd, he, wi, de)+calcLocalDiffY(rd, he, wi-1, de);
							
						if (y>0)
							A[y-1][y]=-calcLocalDiffY(rd, he, wi-1, de);
						if (y<nJi-1)
							A[y+1][y]=-calcLocalDiffY(rd, he, wi, de);	
					}
					
					//set B
					for (int y=0;y<nJi;y++)
					{
						/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
						//this is necessary to get around the corners of the padding 
						if (x==0 || x==nI+1 || z==0 || z==nK+1) /*corrects y in edge-case*/ 
							wi=y+1;
						else /*normal case*/ 
							wi=y; 
						he=x; de=z; /*and the other coordinates (for consistency)*/
							
						if (y==0)
							B[y][y]=diag-calcLocalDiffY(rd, he, wi, de);
						if (y==nJi-1)
							B[y][y]=diag-calcLocalDiffY(rd, he, wi-1, de);
						if (y!=0 && y!=nJi-1)
							B[y][y]=diag-calcLocalDiffY(rd, he, wi, de)-calcLocalDiffY(rd, he, wi-1, de);
							
						if (y>0)
							B[y-1][y]=calcLocalDiffY(rd, he, wi-1, de);
						if (y<nJi-1)
							B[y+1][y]=calcLocalDiffY(rd, he, wi, de);
					}
					
					
					//set d
					for (int y=0;y<nJi;y++)
					{
						/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
						//this is necessary to get around the corners of the padding 
						if (x==0 || x==nI+1 || z==0 || z==nK+1) /*corrects y in edge-case*/ 
							wi=y+1;
						else /*normal case*/ 
							wi=y;		 
						he=x; de=z; /*and the other coordinates (for consistency)*/
							
						double sum=0.0;
						sum=sum+B[y][y]*conc.grid[he][wi][de];
						if (y<nJi-1)
							sum=sum+B[y+1][y]*conc.grid[he][wi+1][de];
						if (y>0)
							sum=sum+B[y-1][y]*conc.grid[he][wi-1][de];
						d[y]=sum;
					}												
						
					//solves the tridiagonal Matrix
					pivotSolver(A, d, t);
						
					//assign Flux
					for (int y=0;y<nJi;y++)
					{
						/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
						//this is necessary to get around the corners of the padding 
						if (x==0 || x==nI+1 || z==0 || z==nK+1) /*corrects y in edge-case*/ 
							wi=y+1;
						else /*normal case*/ 
							wi=y; 
						he=x; de=z; /*and the other coordinates (for consistency)*/
							
						Y[x][y][z]=t[y]-conc.grid[he][wi][de];
					}
				}
			}	
		
		//solve in X
		for (int y=0;y<nJ+2;y++)
			for (int z=0;z<nK+2;z++)
				{
				int nIi;
				if (y==0 || y==nJ+1 || z==0 || z==nK+1)
					nIi=nI;
				else
					nIi=nI+2;	
				
					double[][] A = new double[nIi][nIi];
					double[][] B = new double[nIi][nIi];
					double[] d = new double[nIi];
					double[] t = new double[nIi];
					
					if (nIi==1)
						Y[0][y][z]=0;
					else
					{
						//set A
						for (int x=0;x<nIi;x++)
						{
							/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
							//this is necessary to get around the corners of the padding 
							if (y==0 || y==nJ+1 || z==0 || z==nK+1) /*corrects x in edge-case*/ 
								he=x+1;
							else /*normal case*/ 
								he=x;		 
							wi=y; de=z; /*and the other coordinates (for consistency)*/
						
							if (x==0)
								A[x][x]=diag+calcLocalDiffX(rd, he, wi, de);
							if (x==nIi-1)
								A[x][x]=diag+calcLocalDiffX(rd, he-1, wi, de);
							if (x!=0 && x!=nI+1)
								A[x][x]=diag+calcLocalDiffX(rd, he, wi, de)+calcLocalDiffX(rd, he-1, wi, de);
							
							if (x>0)
								A[x-1][x]=-calcLocalDiffX(rd, he-1, wi, de);
							if (x<nIi-1)
								A[x+1][x]=-calcLocalDiffX(rd, he, wi, de);
							
						}
						
						//set B
						for (int x=0;x<nIi;x++)
						{
							/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
							//this is necessary to get around the corners of the padding 
							if (y==0 || y==nJ+1 || z==0 || z==nK+1) /*corrects x in edge-case*/ 
								he=x+1;
							else /*normal case*/ 
								he=x; 
							wi=y; de=z; /*and the other coordinates (for consistency)*/
							
							if (x==0)
								B[x][x]=diag-calcLocalDiffX(rd, he, wi, de);
							if (x==nI+1)
								B[x][x]=diag-calcLocalDiffX(rd, he-1, wi, de);
							if (x!=0 && x!=nIi-1)
								B[x][x]=diag-calcLocalDiffX(rd, he, wi, de)-calcLocalDiffX(rd, he-1, wi, de);
							
							if (x>0)
								B[x-1][x]=calcLocalDiffX(rd, he-1, wi, de);
							if (x<nIi-1)
								B[x+1][x]=calcLocalDiffX(rd, he, wi, de);
							
						}
						
						//set d
						for (int x=0;x<nIi;x++)
						{
							/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
							//this is necessary to get around the corners of the padding 
							if (y==0 || y==nJ+1 || z==0 || z==nK+1) /*corrects x in edge-case*/ 
								he=x+1;
							else /*normal case*/ 
								he=x;		 
							wi=y; de=z; /*and the other coordinates (for consistency)*/
								
							double sum=0.0;
							sum=sum+B[x][x]*conc.grid[he][wi][de];
							if (x<nIi-1)
								sum=sum+B[x+1][x]*conc.grid[he+1][wi][de];
							if (x>0)
								sum=sum+B[x-1][x]*conc.grid[he-1][wi][de];
							d[x]=sum;
						}
						
						//solves the tridiagonal Matrix
						pivotSolver(A, d, t);
						
						//assign Flux
						for (int x=0;x<nIi;x++)
						{
							/*height*/ int he; /*width*/ int wi; /*depth*/ int de;
							//this is necessary to get around the corners of the padding 
							if (y==0 || y==nJ+1 || z==0 || z==nK+1) /*corrects x in edge-case*/ 
								he=x+1;
							else /*normal case*/ 
								he=x; 
							wi=y; de=z; /*and the other coordinates (for consistency)*/
								
							X[x][y][z]=t[x]-conc.grid[he][wi][de];
						}
					}
				}
		
		//sum the fluxes up
		for (int x=0;x<nI+2;x++)
			for (int y=0;y<nJ+2;y++)
				for (int z=0;z<nK+2;z++)
					XYZ[x][y][z]=(X[x][y][z]+Y[x][y][z]+Z[x][y][z]);
		
		//put them in the stepgrid
		
		for (int x=0;x<nI+2;x++)
			for (int y=0;y<nJ+2;y++)
				for (int z=0;z<nK+2;z++)
				{
					// yep, it's ugly, but once again, we don't want the corners 
					// (they should be 0 anyway, but let's better be safe)
					if (z==0 || y==0 || x==0 || z==nK+1 || y==nJ+1 || x==nI+1);
					else
					{
						if (_bLayer._conc.grid[x][y][z]>BLTHRESH || !refresh)
							conc.grid[x][y][z]=conc.grid[x][y][z]+XYZ[x][y][z];
						else
							conc.grid[x][y][z]=sBulk; // this is disabled if refresh is false
					}
				}
		
		conc.refreshBoundary("conc");
	}

	/* _________________________ TOOLBOX ____________________________ */
	public void resetMultigridCopies(Double value) 
	{
			_conc.setAllValueAt(value);
	}
	
	/**
	 * sets the finest grid of the Multigrid to a certain value
	 * 
	 * @param value
	 */
	public void resetFinest(Double value) 
	{
		_conc.setAllValueAt(value);
	}

	/**
	 * sets the reac and diffReac Grid to 0.0
	 */
	public void resetReaction() 
	{
		_reac.setAllValueAt(0.0);
		_diffReac.setAllValueAt(0.0);
	}

	/**
	 * katrin: Set all grids elements to the value of the last time step. In the very first iteration,
	 * the initial concentration is used.
	 * 
	 * @param _conc the grid that we are supposed to fill
	 * @param _bLayer our boundary-layer grid. If a voxel is not in the boundaryLayer, we set it to bulk
	 */
	public void setSoluteGridToLastTimeStep(SoluteGrid _conc, MultigridSoluteTimeDependent _bLayer) 
	{

		int maxI = _conc.getGridSizeI();
		int maxJ = _conc.getGridSizeJ();
		int maxK = _conc.getGridSizeK();
		
			for (_i = 1; _i<maxI+1; _i++) 			
				for (_j = 1; _j<maxJ+1; _j++) 
					for (_k = 1; _k<maxK+1; _k++) 
					{
						//if (_i==0 || _j==0 || _k==0 ||_i==maxI+1 ||_j==maxJ+1 ||_k==maxK+1)
							//_conc[order].grid[_i][_j][_k] = 0;
						//else
						//{
						if (_bLayer._conc.grid[_i][_j][_k]<=BLTHRESH)
							{ // outside the boundary layer (will not be solved)
							_conc.grid[_i][_j][_k] = sBulk; 
							}
						else
							{ 
							//_conc[order].setValueAt(realGrid.getValueAt(_i,_j,_k), _i, _j, _k); }
							_conc.setValueAt(realGrid.getValueAt(_i,_j,_k),_i, _j, _k);
							}
						//}						
					}
			
			_conc.refreshBoundary("conc");
			
	}

	/**
	 * Calculates a stable dt for the solute, according to the criterion for
	 * our Crank-Nicolson-Method, which is dt<h²/D.
	 * 
	 * @param step 			the amount of time we want to solve (so dt does not get
	 * 						larger than our step).
	 */
	public void computeStableDt(double step) 
	{
		{
			// Calculate our fine spatial resolution.
			Double h = _referenceSystemSide;
			h /= referenceIndex(_conc.getGridSizeI(),
								_conc.getGridSizeJ(),
								_conc.getGridSizeK());
			LogFile.writeLogAlways("h: "+h+" / diff: "+realGrid.diffusivity);
			
			// Our stepping-criterion. The smaller timestep is chosen, because we
			// do more than one dimension and need to choose a smaller timestep to keep it stable
			Double maxTime = 0.2*h*h/realGrid.diffusivity; 
			
			// Computation of our stable timestep.
			Double numOfSteps = Math.ceil(step/maxTime);
			
			// dt is computed to split the miniStep evenly.
			simTimeStep = step/numOfSteps;
			LogFile.writeLogAlways("dt: "+simTimeStep);
		}
	}
	
	/**
	 * does exactly what you would think
	 * 
	 * @return the grid
	 */
	public SoluteGrid getGrid() 
	{
		return _conc;
	}
	
	/**
	 * Inserts a set SoluteGrid into this Multigrid. If we already have a
	 * Grid in _conc, it gets overwritten
	 * 
	 * @param aGrid the grid to be inserted 
	 */
	public void setGrid(SoluteGrid aGrid) 
	{
		_conc = aGrid;
	}

	/**
	 * Determine order of the finest grid.
	 */
	public void setReferenceSide() 
	{
		_referenceSystemSide = realGrid.getResolution() * 
												referenceIndex(_nI, _nJ, _nK);
	}
	
	/**
	 * Returns the smallest integer of the arguments
	 * 
	 * @param i the length of 1st dimension
	 * @param j the length of 2nd dimension
	 * @param k the length of 3rd dimension
	 * @return the smallest dimension
	 */
	public int referenceIndex(int i, int j, int k) 
	{
		if (k > 1)
			return Math.min(i, Math.min(j,k));
		return Math.min(i,j);
	}

	/**
	 * \brief Writes _conc.grid to our realGrid.
	 * 
	 * The _conc.grid should be used by the solver internally, while the
	 * realGrid is the actual representation of our solute field 
	 * throughout the simulation.
	 */
	public void applyComputation() 
	{
		MatrixOperations.copyValuesTo(realGrid.grid, _conc.grid);
		
		for (int i=0;i<realGrid.grid.length;i++)
			LogFile.writeLogAlways("conc: "+realGrid.grid[i][1][1]);
	}	
}
